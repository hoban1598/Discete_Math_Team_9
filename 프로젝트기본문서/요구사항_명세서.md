

1. 시스템 개요

1.1 목적

본 프로그램의 목적은 다음과 같다.
	1.	텍스트 파일로 정의된 그래프 정보를 읽어들여,
	•	깊이 우선 탐색(DFS)
	•	너비 우선 탐색(BFS)
을 수행하고 방문 순서를 출력한다.
	2.	가중치가 있는 그래프에 대해 Dijkstra 알고리즘을 이용하여
	•	시작 정점(1번)에서 모든 정점까지의 최단 경로와
	•	해당 경로의 길이(가중치 합)
를 계산·출력한다.

1.2 실행 환경 및 언어
	•	언어: Java (JDK 8 이상 권장)
	•	실행 환경:
	•	콘솔 기반 실행 (Command Line Application)
	•	표준 입력은 사용하지 않고, input1.txt, input2.txt 파일을 프로그램과 동일 디렉터리에 둔다.

⸻

2. 입력/출력 요구사항

2.1 입력 파일 공통 규칙
	•	입력 파일 이름은 반드시 아래와 같이 고정한다.
	•	그래프 탐방용: input1.txt
	•	최단 경로용: input2.txt
	•	각 파일에는 여러 개의 그래프 정보가 순차적으로 포함될 수 있다.
	•	각 그래프는 다음과 같은 형식으로 저장된다.

⸻

2.2 input1.txt 형식 (DFS/BFS용, 무가중치 그래프)

2.2.1 그래프 제약
	•	그래프 유형: 단순 연결 그래프 (simple connected graph)
	•	정점 번호: 1 부터 시작하는 연속된 자연수
	•	정점 수: 최대 100개
	•	간선 방향:
	•	파일에 쓰인 인접 노드는 방향을 가진다.
	•	무방향 그래프를 표현하려면, 양쪽 방향을 모두 작성해야 한다.
	•	각 정점의 인접 정점은 오름차순으로 나열한다.

2.2.2 형식
각 그래프는 다음과 같이 구성된다.
	1.	첫 줄: 그래프의 정점 개수 N
	2.	다음 N줄: 각 줄은
	•	맨 앞에 정점 번호
	•	이어서 해당 정점에 인접한 정점 번호들을 공백으로 구분하여 나열

예시(한 개의 그래프):

8
1 2 3
2 1 4 5
3 1 6 7
4 2 8
5 2 8
6 3 8
7 3 8
8 4 5 6 7

두 개 이상 그래프가 있을 경우, 위 형식이 연달아 반복된다.

⸻

2.3 input2.txt 형식 (Dijkstra용, 가중치 그래프)

2.3.1 그래프 제약
	•	정점 번호: 1 부터 시작하는 연속된 자연수
	•	가중치: 0보다 큰 정수
	•	인접 정점은 오름차순으로 나열
	•	그래프는 방향 그래프로 해석되며, 무방향을 원할 경우 양쪽 방향 모두 기술

2.3.2 형식
각 그래프는 다음과 같이 구성된다.
	1.	첫 줄: 그래프의 정점 개수 N
	2.	이후 여러 줄:
각 줄은
	•	정점번호 인접정점1 가중치1 인접정점2 가중치2 ...
형식으로 구성

예시(한 개의 그래프):

5
1 2 7 3 4 4 6 5 1
2
3 2 2 4 5
4 2 3
5 4 1


⸻

2.4 출력 요구사항

2.4.1 출력 전체 흐름
프로그램은 다음 순서로 출력한다.
	1.	input1.txt에 포함된 각 그래프에 대해
	•	그래프 번호 [k]를 표시하고
	•	DFS 결과
	•	BFS 결과
를 순차적으로 출력
	2.	모든 그래프 탐방이 끝난 뒤,
	3.	input2.txt에 포함된 각 그래프에 대해
	•	시작점 1에서 각 정점까지의 최단 경로 및 경로 길이를 출력

2.4.2 DFS/BFS 출력 형식
	1.	가장 먼저 헤더:

1. 그래프 탐방 수행 결과


	2.	그래프 하나당:

그래프 [k]
----------------------------
깊이 우선 탐색
1 – 2 – 4 – 8 – 5 – 6 – 3 – 7 
너비 우선 탐색
1 – 2 – 3 – 4 – 5 – 6 – 7 – 8 
============================



	•	정점 사이 구분자는 예시처럼 " – "(양쪽 공백 포함 하이픈) 사용
	•	DFS/BFS의 시작 정점은 항상 1번 정점으로 한다.

2.4.3 최단 경로 출력 형식
	1.	가장 먼저 헤더:

2. 최단 경로 구하기 수행 결과


	2.	그래프 하나당:

그래프 [k]
----------------------------
시작점: 1
정점 [2]: 1 – 5 – 4 – 2, 길이: 5
정점 [3]: 1 – 3, 길이: 4
...
=========================



	•	각 정점 v (2..N)에 대해 1에서 v까지의 경로와 총 가중치 출력
	•	경로의 길이가 같은 경우, 먼저 찾은 경로를 유지하도록 Dijkstra 구현 시 <인 경우에만 갱신(≤ 사용 금지)

⸻

3. 기능 요구사항

3.1 그래프 입력 모듈

FR-1. 프로그램은 input1.txt에서 EOF까지 그래프를 반복해서 읽어야 한다.
FR-2. 프로그램은 input2.txt에서 EOF까지 그래프를 반복해서 읽어야 한다.
FR-3. 각 그래프마다:
	•	정점 수 N을 읽고
	•	정점 번호 및 인접 목록/가중치 정보를 파싱한다.

FR-4. 잘못된 포맷(정점 번호 범위 초과, 홀수 개의 가중치 항목 등)이 감지되면, 에러 메시지를 출력하고 해당 그래프 처리를 건너뛰거나 프로그램을 종료한다(팀 정책에 맞게 명시).

⸻

3.2 그래프 표현 모듈 (인접 행렬)

FR-5. 모든 그래프는 인접 행렬(2차원 배열) 로 표현해야 한다.
	•	인접 리스트 사용 금지
	•	무가중치 그래프 (input1.txt):
	•	adj[i][j] = 1 (간선 있음)
	•	adj[i][j] = 0 (간선 없음)
	•	가중치 그래프 (input2.txt):
	•	adj[i][j] = w (간선 가중치)
	•	adj[i][j] = INF (또는 0 혹은 -1 등 “없음”을 의미하는 값) (간선 없음)

⸻

3.3 DFS 기능

FR-6. DFS는 재귀 또는 스택을 사용하여 구현할 수 있다.
FR-7. 시작 정점은 항상 1번 정점으로 고정한다.
FR-8. 방문 순서는 다음 규칙을 따른다.
	•	현재 정점에서 인접한 정점들 중 번호가 작은 정점부터 방문
	•	이미 방문한 정점은 재방문하지 않는다.
FR-9. DFS 결과는 예시 형식에 맞춰 단일 행으로 출력한다.

⸻

3.4 BFS 기능

FR-10. BFS는 큐(Queue) 를 사용하여 구현한다.
FR-11. 시작 정점은 DFS와 마찬가지로 1번 정점이다.
FR-12. 탐색 시 인접 정점은 번호가 작은 것부터 큐에 추가한다.
FR-13. BFS 결과 역시 예시 형식에 맞춰 단일 행으로 출력한다.

⸻

3.5 Dijkstra 최단 경로 기능

FR-14. Dijkstra 알고리즘을 이용하여 시작 정점 1에서 모든 정점 v (2..N)까지의 최단 거리 및 경로를 구한다.
FR-15. 우선순위 큐 사용 여부는 자유이나, 인접 행렬 기반으로 구현해야 한다.
FR-16. 최단 경로를 복원하기 위해 각 정점의 이전 정점(parent 또는 predecessor) 정보를 저장한다.
FR-17. 거리 갱신 조건은 다음을 따른다.
	•	if (새로운_거리 < 기존_거리) 인 경우에만 갱신 (같을 때는 갱신 금지)
FR-18. 각 정점 v에 대해:
	•	1 – ... – v 의 경로를 “ – ”로 구분해 출력
	•	길이: X 형태로 총 가중치 출력

FR-19. 도달할 수 없는 정점이 존재할 경우(이론상 없도록 입력이 구성되지만),
	•	별도의 메시지 또는 무한대 처리를 명시적으로 정의한다.

⸻

4. 비기능 요구사항

4.1 성능
	•	정점 개수 N ≤ 100 범위에서,
	•	DFS/BFS는 O(N^2) (인접 행렬 기준)
	•	Dijkstra는 O(N^2) 구현을 기준으로 한다.
	•	프로그램은 주어진 입력 크기 내에서 실행 시간 제한 없이 충분히 빠르게 동작해야 한다.

4.2 코드 구조 (Java 관점)

NFR-1. 권장 클래스 구조 예시 (필수는 아님, 보고서용):
	•	Main
	•	public static void main(String[] args)
	•	전체 실행 흐름 제어:
	1.	input1.txt 처리 → DFS/BFS 결과 출력
	2.	input2.txt 처리 → 최단 경로 결과 출력
	•	Graph
	•	필드: int n, int[][] adjMatrix 등
	•	메서드: addEdge(...) 등
	•	GraphTraversal
	•	static List<Integer> dfs(Graph g, int start)
	•	static List<Integer> bfs(Graph g, int start)
	•	Dijkstra
	•	static Result dijkstra(Graph g, int start)
	•	Result 안에 dist[], parent[] 등 포함

NFR-2. 코드 가독성을 위해 의미 있는 변수·메서드 이름 사용
예: numVertices, visited, distance, previous, readGraphsFromFile 등

4.3 입출력 및 에러 처리

NFR-3. 파일이 존재하지 않을 경우
	•	"input1.txt 파일을 찾을 수 없습니다." 등 사용자 친화적인 메시지를 출력 후 종료

NFR-4. 입력 형식 오류 발생 시
	•	어느 그래프에서 문제가 발생했는지 알 수 있는 메시지를 출력
	•	가능한 경우, 나머지 그래프 처리는 계속 진행

NFR-5. 출력 형식은 과제에서 제시한 예시와 공백, 줄바꿈까지 최대한 동일하게 맞추는 것을 목표로 한다.

⸻

5. 테스트 요구사항

5.1 필수 테스트 케이스 유형

프로그램 검증을 위해 최소 5개 이상의 그래프에 대해 다음과 같은 케이스를 포함한다.
	1.	선형 그래프 (1-2-3-4 형태)
	2.	완전 그래프 (모든 정점이 서로 연결)
	3.	트리 형태 그래프 (루트에서 여러 레벨로 뻗는 구조)
	4.	가중치가 다양한 그래프 (짧은 경로 vs 많은 간선 수 비교)
	5.	무방향 그래프를 양방향 간선으로 표현한 케이스

각 케이스에 대해:
	•	DFS/BFS 방문 순서가 수작업 계산과 일치하는지 확인
	•	Dijkstra 최단 경로 및 길이가 수작업 계산과 일치하는지 확인

⸻

6. 확장/변경 가능 항목 (선택)
	•	명령행 인자로 입력 파일 이름을 변경해서 받도록 확장할 수 있으나,
평가 시에는 input1.txt, input2.txt 이름을 사용할 것을 전제로 구현한다.
	•	로그 출력을 위해 디버그 모드(예: -Ddebug=true)를 둘 수 있으나,
최종 제출용 실행에서는 과제에서 요구한 출력 외 불필요한 출력은 제거한다.

⸻

